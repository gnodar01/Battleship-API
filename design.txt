Additional Properties added to models:

- The ndb models used include User, Game, Piece, and Miss.

  - The most "unique" aspect of the Game model is the game's history Field. This includes of all the moves made for the game stored as JSON. Normally, in a relational databse, this many (moves) to one (game) relationship would warrant seperating these into different tables. However given that the datastore is not a relationial databse, I figured I would take liberties. Part of the justification for this was simply to utilize ndb.JsobProperty, which I wanted to experiment with. Mostly though, It solved the problem of sorting the history before returning in a response. If seperating the game history out as a seperate Kind, I would need to query by the game's ID, and then sort based on a move_number field. Witht he ndb.JsonProperty, the moves are pushed into the array in the order that they occur, so they retain the proper sorting.

  - The hit_marks field in Piece, like the history field in Game, *could* have been broken out as a seperate Kind. The arguments for keeping it as a Field rather than a seperate Kind are similar for the arguments for keeping history as a Field of Game. The difference is that it is a repeated ndb.StringProperty, rather than as a ndb.JsonProperty. A repeated ndb.StringProperty is essentially an Array, which is the same strucutre I would have stored the hits in after querying and sorting them, so I figured I would skip that step and just store it as a Field of Piece.

Trade-offs or struggles faced when implementing the new game logic:

The biggest struggle was really two sides of the same coin; namely, validating requests and responding with errors on incorrect requests. Most of the models, and the overall structure of the API, were pre-planned. The validation however, I failed to fully define during the planning phase. Most of the validation was done on the fly, as I would think of new ways that an incorrect request could be sent. I had to take into account things such as pieces being placed off the board, pieces being placed on top of each other, players moving when it's not their turn, moves being made before the game started or after it ended, invalid coordinates, etc. It was difficult to think all situations through ahead of time, and I discovered a few well after writing the original logic handling the request. As a result most of the validation is disperesed throughout the code a little more haphazardly than I would like. I would have prefered to make a whole validation module. I tried "breaking" my own code as much as possible to discover all possible user erros, but I imaginge there are still several invalid requests that can be made, which I have not been able to think of.